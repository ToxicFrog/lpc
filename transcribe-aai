#!/bin/bash
# :mode=bash:

# missing: 171, 172, 183, 199

# Configurable bits

# detect image x y image x y image x y...
function detect {
  while [[ $1 ]]; do
    local w=$(echo "$1" | tr -d B | wc -c)
    if (( w > 2 )); then
      local thresh=10%
    else
      local thresh=90%
    fi
    local diff=$(
      diff-images "$IMAGE" "$BASEDIR/$1.png" \
      -crop "4x4+$2+$3" -colorspace Gray -normalize -threshold $thresh)
    (( diff > 0 )) && return 1
    shift 3
  done
  return 0
}

# Called to read the text out of an image.
function READ {
  # Text at top.
  # Coordinates for text TL TR, nameplate TL TR BL.
  if detect BBBW 0 0 BBWB 508 0 WBWW 0 106 WBWW 92 106 WWBW 0 130; then
    ocr nameplate -crop 88x20+4+110 -intensity Rec709Luma -threshold 90% -negate
    ocr text -crop 464x102+16+4 -intensity Brightness -threshold 90% -negate
    output
  fi

  if detect BWWW 0 250 WWWB 0 274 WWWB 92 274 BWBB 0 380 WBBB 508 380; then
    ocr nameplate -crop 88x20+4+254 -intensity Rec709Luma -threshold 90% -negate
    ocr text -crop 464x102+16+278 -intensity Brightness -threshold 90% -negate
    output
  fi

  if detect BWWW 0 202 WWWB 0 226 WWWB 92 226 BWBB 0 332 WBBB 508 332; then
    ocr nameplate -crop 88x20+4+206 -intensity Rec709Luma -threshold 90% -negate
    ocr text -crop 464x102+16+230 -intensity Brightness -threshold 90% -negate
    output
  fi
}

# Called to postprocess the text before writing it out.
function POST/nameplate {
  # Remove leading and trailing whitespace, and collapse '?? ' into '? ' since
  # a pecularity of OCRing '? ? ?' in the nameplate causes it to render as
  # '?? ?? ?? ' instead.
  sed -E 's/\?\? /\? /g; s/^ +//; s/ +$//'
}

function POST/text {
  tr '\n' ' ' \
    | sed -E "
      # Replace things like I,m and it,s with I'm and it's, since the OCR has
      # trouble distinguishing between ' and ,
      s/([A-Za-z]),([A-Za-z])/\\1'\\2/g

      # It tends to read '...' as '. . . ', so fix that
      s/\\. \\. \\. /.../g

      # Trim whitespace before closing paren.
      s/ +\)/)/g

      # Remove leading and trailing whitespace
      s/^ +//; s/ +$//
    "
}

# Called to write the text out to the transcription file.
function WRITE {
  echo "# $IMAGE"
  echo "[$(get nameplate)] $(get text)"
  echo ""
}

#### No user serviceable parts below this line. ####

shopt -s lastpipe

declare -r BASEDIR="$(dirname "$0")"

# diff-images basis template im-args...
function diff-images {
  local img="$1"
  local pattern="$2"
  shift 2
  compare <(convert "$img" "$@" bmp:-) "$pattern" \
    -metric AE bmp:/dev/null 2>&1
}

# ocr <key name> <convert arguments...>
# upvalues: IMAGE, the image to read; OCR[$key], the destination for the text
function ocr {
  local key="$1"; shift
  mkdir -p "$key.ocr"
  # cp "$2" test.png
  # convert $3 "$2" ocr.png

  gocr -p "$key.ocr/" -m $((256+128+2)) -d 0 -a 99 -f ASCII \
    -i <(convert "$IMAGE" "$@" pnm:-) \
    -o /tmp/$$ 2>&1 | sed -E '
      s/^Press RET.*/\x1B[2J/
      /^#/ d
      y/,O#./░▒█ /
      s/([a-z])  /\1. /g
    ' >&2
  OCR[$key]=$(cat /tmp/$$ | POST/$key)
  rm /tmp/$$
}

function output {
  WRITE >> "$TRANSCRIPT"
}

# get <key>
# Get the text associated with a key in the current OCR context.
# Upvalues: OCR, the key->text map.
function get {
  echo -n "${OCR[$1]}"
}

function main {
  local -r TRANSCRIPT="$1"; shift
  echo > "$TRANSCRIPT"

  local IMAGE
  for IMAGE in $(printf '%s\n' "$@" | sort -g); do
    echo "$IMAGE"
    local -A OCR=()
    READ
  done
  cat "$TRANSCRIPT"
}

main "$@"

